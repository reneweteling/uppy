name: Semantic Release

on:
  push:
    branches:
      - main

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

jobs:
  version:
    name: Version
    runs-on: ubuntu-latest
    environment: production
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install pnpm dependencies
        shell: bash
        run: pnpm install --frozen-lockfile

      - name: Update version numbers
        id: version
        shell: bash
        run: |
          # Configure git for semantic-release
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Run semantic-release dry-run to update package.json version
          pnpm semantic-release --dry-run --no-ci

          # Read the updated version from package.json
          UPDATED_VERSION=$(node -p "require('./package.json').version")
          echo "Updated version: $UPDATED_VERSION"


          echo "version=$UPDATED_VERSION" >> $GITHUB_OUTPUT

  build:
    name: Build ${{ matrix.platform }}
    runs-on: ${{ matrix.runs-on }}
    needs: version
    environment: production
    strategy:
      matrix:
        include:
          - platform: macOS
            runs-on: macos-latest
            bundle: dmg
          # - platform: Linux
          #   runs-on: ubuntu-latest
          #   bundle: deb
          # - platform: Windows
          #   runs-on: windows-latest
          #   bundle: msi
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.9

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Setup Rust cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
            !src-tauri/target/release/bundle/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Setup Windows-specific cache (Windows only)
        if: matrix.platform == 'Windows'
        uses: actions/cache@v4
        with:
          path: |
            C:\Users\runner\.cargo\bin\
            C:\Users\runner\.cargo\registry\index\
            C:\Users\runner\.cargo\registry\cache\
            C:\Users\runner\.cargo\git\db\
            src-tauri\target\
            !src-tauri\target\release\bundle\
          key: windows-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            windows-cargo-

      - name: Install pnpm dependencies
        shell: bash
        run: pnpm install --frozen-lockfile

      - name: Pre-compile Rust dependencies (Windows only)
        if: matrix.platform == 'Windows'
        shell: bash
        run: |
          echo "Pre-compiling Rust dependencies for Windows..."
          cd src-tauri
          cargo check --release
          echo "Dependencies pre-compiled successfully"

      - name: Clear old builds
        run: rm -rf src-tauri/target/release/bundle/${{ matrix.bundle }}/
        shell: bash

      - name: Update version numbers
        id: version
        shell: bash
        run: |
          # Update Cargo.toml and tauri.conf.json versions to match package.json
          node -e "
            const fs = require('fs');

            // Update Cargo.toml
            const cargoContent = fs.readFileSync('src-tauri/Cargo.toml', 'utf8');
            const updatedCargo = cargoContent.replace(/^version = \".*\"/m, 'version = \"${{ needs.version.outputs.version }}\"');
            fs.writeFileSync('src-tauri/Cargo.toml', updatedCargo);

            // Update tauri.conf.json
            const tauriConfig = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            tauriConfig.version = '${{ needs.version.outputs.version }}';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(tauriConfig, null, 2));

            console.log('Updated Cargo.toml and tauri.conf.json versions to ${{ needs.version.outputs.version }}');
          "

      - name: Install system dependencies (Linux)
        uses: awalsh128/cache-apt-pkgs-action@latest
        if: matrix.platform == 'Linux'
        with:
          packages: libgtk-3-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev libwebkit2gtk-4.1-dev
          version: 1.0

      - name: Build ${{ matrix.platform }}
        run: pnpm tauri build --bundles ${{ matrix.bundle }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_BUCKET: ${{ secrets.AWS_BUCKET }}

      - name: Upload ${{ matrix.platform }} artifacts
        uses: actions/upload-artifact@v4
        with:
          name: uppy-${{ matrix.platform }}-v${{ needs.version.outputs.version }}
          path: |
            src-tauri/target/release/bundle/${{ matrix.bundle }}/*.${{ matrix.bundle }}
          retention-days: 1

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [version, build]
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        shell: bash
        run: pnpm install --frozen-lockfile

      - name: Clean up old artifacts
        shell: bash
        run: |
          rm -rf artifacts/
          echo "Cleaned up old artifacts"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare release assets
        shell: bash
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          echo "Preparing assets for version: $VERSION"

          # Clean up any existing bundle directories
          rm -rf src-tauri/target/release/bundle/dmg
          rm -rf src-tauri/target/release/bundle/deb
          rm -rf src-tauri/target/release/bundle/msi

          # Create the expected directory structure for semantic-release
          mkdir -p src-tauri/target/release/bundle/dmg
          mkdir -p src-tauri/target/release/bundle/deb
          mkdir -p src-tauri/target/release/bundle/msi

          # List all downloaded artifacts
          echo "Downloaded artifacts:"
          find artifacts -type f -name "*.dmg" -o -name "*.deb" -o -name "*.msi" 2>/dev/null || echo "No artifacts found"

          # Copy only artifacts that match the current version
          find artifacts -name "*${VERSION}*.dmg" -exec cp {} src-tauri/target/release/bundle/dmg/ \; 2>/dev/null || true
          find artifacts -name "*${VERSION}*.deb" -exec cp {} src-tauri/target/release/bundle/deb/ \; 2>/dev/null || true
          find artifacts -name "*${VERSION}*.msi" -exec cp {} src-tauri/target/release/bundle/msi/ \; 2>/dev/null || true

          # If no version-specific files found, try without version matching (fallback)
          if [ ! "$(find src-tauri/target/release/bundle -name "*.dmg" -o -name "*.deb" -o -name "*.msi" 2>/dev/null)" ]; then
            echo "No version-specific artifacts found, trying fallback..."
            find artifacts -name "*.dmg" -exec cp {} src-tauri/target/release/bundle/dmg/ \; 2>/dev/null || true
            find artifacts -name "*.deb" -exec cp {} src-tauri/target/release/bundle/deb/ \; 2>/dev/null || true
            find artifacts -name "*.msi" -exec cp {} src-tauri/target/release/bundle/msi/ \; 2>/dev/null || true
          fi

          # List what we have in the final locations
          echo "Final assets:"
          find src-tauri/target/release/bundle -name "*.dmg" -o -name "*.deb" -o -name "*.msi" 2>/dev/null || echo "No final assets found"

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run semantic-release
        shell: bash
        run: pnpm semantic-release

      - name: Create PR to merge main into develop
        if: success()
        continue-on-error: true
        run: |
          gh pr create \
            --base develop \
            --head main \
            --title "Merge release ${{ needs.version.outputs.version }} to develop" \
            --body "This PR merges the latest release (v${{ needs.version.outputs.version }}) from \`main\` into \`develop\`.\n\n**Release Details:**\n- Version: v${{ needs.version.outputs.version }}\n- Release URL: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.version.outputs.version }}\n\nThis ensures the develop branch stays up to date with the latest stable release." \
            --label "automated,release"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
